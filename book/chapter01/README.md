# gRPC 소개

현대 SW 시스템은 여러 네트워크 위치에서 실행되고 다양한 통신 프로토콜을 사용한 <u>메시지 전송을 통해 서로 통신하는 분산 애플리케이션 구성</u>이다.

> 마이크로서비스 아키텍처
>
> 독립적이고 자율적이며, 비즈니스 중심의 느슨하게 결합된 서비스 모음

- 마이크로서비스 기반으로 구축되는 시스템은 프로세스 간 통신 기술을 사용해 네트워크로 연결해야 한다 
- 프로세스간 통신은 동기식 요청-응답  synchronous request-response / 비동기 이벤트 기반 asyncronous event-driven 으로 구현된다 

RESTful 서비스는 HTTP1.0을 사용하며 프로세스 간 통신을 구축할 때 부피가 크고 비효율적이며 에러가 쉽게 발생한다.

gRPC는 주로 통신에 동기식 요청-응답 스타일을 사용하지만 초기 통신이 설정되면 완전 비동기식이거나 스트리밍 모드에서 작동할 수 있다 

## gRPC

gRPC 서비스를 구축하는 첫 번째 단계는 입력 파라미터 및 반환 타입과 서비스의 메서드를 서비스 인터페이스 정의로 만드는 것이다

### 서비스 정의

 gRPC 는 프로토콜 버퍼를 IDL(인터페이스 정의 언어)로 사용해 서비스 인터페이스를 정의한다.

프로토콜 버퍼는 언어에 상관없이 플랫폼 중립적이며 확장 가능한 매케니즘으로 구조화된 데이터를 직렬화할 때 사용된다.



### gRPC 서버

사용자 정의 완료 후 프로토콜 버퍼 컴파일러인 protoc를 사용해 코드를 생성한다 

### gRPC 클라이언트 

서비스 정의를 사용해 클라이언트 스텁을 생선한다. 

### 클라이언트-서버 메시지 흐름

gRPC 클라이언트가 gRPC 서비스를 호출할 때 클라이언트의 gRPC 라이브러리는 프로토콜 버퍼를 사용해 원격 프로시저 호출 프로토콜 버퍼 형식으로 마샬링하고 HTTP/2를 통해 전송된다.

서버는 요청을 언마샬링하고 각 프로시저 호출은 프로토콜 버퍼에의해 실행된다 

> 마샬링은 파라미터와 원격 함수를 네트워크 상에 전송되는 메시지 패킷으로 패킹하는 프로세스이며 언마샬링은 메시지 패킷을 각 메서드 호출로 다시 복원하는 것이다

전송 프로토콜은 양방향 메시징을 지원하는 고성능 바이너리 프로토콜인  HTTP/2를 사용한다 

### REST

분산 애플리케이션을 리소스 모음으로 모델린하는 자원 지향 아키텍처 기반이며 리소스에 접근하는 클라이언트가 해당 리소스 상태 CRUD 를 변경할 수 있다 

#### 비효율적인 텍스트 기반 메시지 프로토콜

RESTful 서비스는 HTTP/1 같은 텍스트 기반 전송 프로토콜로 구축되며 JSON처럼 텍스트 포맷을 사용한다. 서비스 간 통신은 텍스트 기반 포맷을 사용할 필요가 없기 때문에 JSON과 같은 텍스트 포맷은 비효율적이다 

#### 왜 gRPC인가?

#### gRPC 장점

1. 프로세스 간 통신 효율성
   - 텍스트 형식을 사용하는 대신 프로토콜 버퍼 기반 바이너리 프로토콜을 사용하여 gRPC 서비스 및 클라이언트와 통신한다 

2. 간단 명확한 서비스 인터페이스와 스키마
   - 계약 우선 접근 방식 권장
   - 서비스 인터페이스 정의 후 구현 세부 사항 작업

3. 엄격한 타입 점검 형식
   - 프로토콜 버퍼 사용
   - gRPC 서비스 계약은 앱 간 통신에 사용할 데이터 타입을 명확하게 정의한다 

4. 폴리그랏
   - 프로토콜 버퍼 기반 gRPC 서비스 정의는 특정 언어에 한정되지 않습니다

5. 이중 스트리밍
   - 클라이언트 / 서버 스트리밍을 기본적으로 지원
   - 서비스 정의 자체에 포함되어 쉽게 개발

6. 유용한 내장 기능 지원
   - 인증, 암호화, 복원력(데드라인과 타임라인), 메타데이터 교환, 압축, 로드밸런싱, 서비스 검색 지원
7. 클라우드 네이티브 생태계와 통합

#### gRPC 단점

1. 외부 서비스 부적합
   - 계약 기반이면서 강한 타입 속성을 갖는 gRPC 서비스는 외부 당사자에게 노출되는 서비스의 유연성을 방해한다 
   - gRPC 게이트웨이는 이 문제에 대한 해결책이다 

2. 서비스 정의의 급격한 변경에 따른 개발 프로세스 복잡성
   - gRPC 서비스 정의가 급격히 변경되면 클라이언트, 서버 코드 모드 재생성해야한다
   - 전체 개발 수명 주기를 복잡하게 할 수 있다 
   - 서비스 정의 변경은 서비스 계약을 위반하지 않고 대부분 수용된다 

3. 상대적으로 작은 생태계
   - gRPC 생태계는 기존 REST, HTTP 프로토콜에 비해 상대적으로 작다 

#### GraphQL

- 클라이언트가 서버에게 요청하는 데이터에 대해 통제력이 더 필요한 경우처럼 소비자에게 직접 노출되는 외부 서비스나 API에 더 적합하다 

